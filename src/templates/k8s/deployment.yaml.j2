# ============================================================================
# KUBERNETES DEPLOYMENT TEMPLATE
# ============================================================================
# Purpose: Production-ready Deployment for containerized applications
#
# Required Variables:
#   - service_name: Name of the service (e.g., "billing", "api-gateway")
#   - namespace: Kubernetes namespace (e.g., "production", "staging")
#   - image: Docker image URL (e.g., "registry.mts.ru/app:v1.0.0")
#
# Optional Variables:
#   - replicas: Number of pod replicas (default: 3)
#   - port: Application port (default: 8080)
#   - cpu_request: CPU request (default: "500m")
#   - cpu_limit: CPU limit (default: "2")
#   - memory_request: Memory request (default: "512Mi")
#   - memory_limit: Memory limit (default: "2Gi")
#   - env_vars: Dictionary of environment variables
#   - volumes: List of volume mounts
#   - secrets: List of secrets to mount
#
# Features:
#   ✓ Prometheus metrics annotations
#   ✓ Health checks (liveness/readiness probes)
#   ✓ Resource requests/limits
#   ✓ Rolling update strategy
#   ✓ Auto-restart on failure
#
# Example Usage:
#   template.render(
#       service_name='billing',
#       namespace='production',
#       image='registry.mts.ru/billing:latest',
#       replicas=5,
#       cpu_request='1',
#       memory_request='2Gi'
#   )
# ============================================================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ service_name }}
  namespace: {{ namespace }}
  labels:
    app: {{ service_name }}
    version: v1
    managed-by: mts-deploy-ai
  annotations:
    description: "{{ description | default('Generated by MTS Deploy AI') }}"
spec:
  replicas: {{ replicas | default(3) }}

  # Rolling update strategy for zero-downtime deployments
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  selector:
    matchLabels:
      app: {{ service_name }}

  template:
    metadata:
      labels:
        app: {{ service_name }}
        version: v1
      annotations:
        # Prometheus metrics scraping
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"

    spec:
      {% if high_availability | default(false) %}
      # High Availability: Spread pods across nodes
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - {{ service_name }}
              topologyKey: kubernetes.io/hostname
      {% endif %}

      containers:
      - name: {{ service_name }}
        image: {{ image }}
        imagePullPolicy: IfNotPresent

        # Application ports
        ports:
        - containerPort: {{ port | default(8080) }}
          name: http
          protocol: TCP
        - containerPort: 9090
          name: metrics
          protocol: TCP

        # Environment variables
        {% if env_vars %}
        env:
        {% for key, value in env_vars.items() %}
        - name: {{ key }}
          value: "{{ value }}"
        {% endfor %}
        {% endif %}

        # Resource limits (important for cost optimization!)
        resources:
          requests:
            cpu: "{{ cpu_request | default('500m') }}"
            memory: "{{ memory_request | default('512Mi') }}"
          limits:
            cpu: "{{ cpu_limit | default('2') }}"
            memory: "{{ memory_limit | default('2Gi') }}"

        # Liveness probe: Restart container if unhealthy
        livenessProbe:
          httpGet:
            path: {{ health_path | default('/health') }}
            port: {{ port | default(8080) }}
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

        # Readiness probe: Remove from service if not ready
        readinessProbe:
          httpGet:
            path: {{ ready_path | default('/ready') }}
            port: {{ port | default(8080) }}
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3

        {% if volumes %}
        # Volume mounts
        volumeMounts:
        {% for volume in volumes %}
        - name: {{ volume.name }}
          mountPath: {{ volume.mount_path }}
          {% if volume.read_only %}
          readOnly: true
          {% endif %}
        {% endfor %}
        {% endif %}

        {% if security_context | default(false) %}
        # Security context
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: {{ read_only_root | default(false) }}
          capabilities:
            drop:
            - ALL
        {% endif %}

      {% if volumes %}
      # Volumes
      volumes:
      {% for volume in volumes %}
      - name: {{ volume.name }}
        {% if volume.type == 'configmap' %}
        configMap:
          name: {{ volume.source }}
        {% elif volume.type == 'secret' %}
        secret:
          secretName: {{ volume.source }}
        {% elif volume.type == 'pvc' %}
        persistentVolumeClaim:
          claimName: {{ volume.source }}
        {% endif %}
      {% endfor %}
      {% endif %}

      {% if image_pull_secrets %}
      # Image pull secrets for private registries
      imagePullSecrets:
      {% for secret in image_pull_secrets %}
      - name: {{ secret }}
      {% endfor %}
      {% endif %}

      # Restart policy
      restartPolicy: Always

      # DNS policy
      dnsPolicy: ClusterFirst
